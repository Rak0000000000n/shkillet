using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.InputSystem;

public class move_script : MonoBehaviour
{
    [Header("Настройки камеры")]
    public Transform cam;

    [Space(12)]
    [Header("Скорости движения")]
    public float walkSpeed;
    public float runSpeed;
    public float sitSpeed;
    public float sitNrunSpeed;
    public float jumpSpeed;

    [Space(12)]
    [Header("Скорости вращения")]
    public float walkRotationSpeed;
    public float runRotationSpeed;
    public float sitRotationSpeed;
    public float sitNrunRotationSpeed;
    public float jumpRotationSpeed;

    [Space(12)]
    [Header("Сидение")]
    public bool isSiting; // Флаг, указывающий, сидит ли персонаж

    [Space(12)]
    [Header("Анимация")]
    private Animator anim;

    [Space(12)]
    [Header("Изменение высоты")]
    private CapsuleCollider capsuleCollider;
    private float currentHeight;
    private float targetHeight;
    private float smoothTime = 0.55f; // Время плавного перехода (в секундах)
    private float velocity = 0f; // Переменная для скорости изменения высоты
    private Vector3 colliderOffset; // Смещение коллайдера

    [Space(12)]
    [Header("Дополнительные настройки")]
    private float speedChangeRate = 8f; // Скорость изменения скорости (чем больше значение, тем быстрее изменяется скорость)

    [Space(12)]
    [Header("Словарь высот")]
    // Справочный словарь для хранения высоты персонажа в каждой анимации
    private Dictionary<string, float> animationHeights = new Dictionary<string, float>()
    {
        {"not Sit", 1.85f},
        {"Sit", 1.48f},
    };

    [Space(12)]
    [Header("Прыжок")]
    public float jumpForce; // Сила прыжка
    public bool g;
    // Время, которое персонаж должен провести в воздухе, 
    // чтобы деактивировать флажок isJumping
    public float timeInAirThreshold = 0.2f;
    // Время, которое персонаж провел в воздухе
    private float timeInAir = 0f;
    // Новая переменная для сохранения скорости движения при прыжке
    private Vector3 jumpVelocity;

    // Переменные для движения
    private Vector3 movement;
    private bool isRunning;
    private float currentSpeed; // Текущая скорость движения
    private float currentRotationSpeed; // Текущая скорость вращения

    // Флаги для состояния движения
    private bool isJumping = false;

    // Добавляем targetSpeed и targetRotationSpeed как члены класса
    private float targetSpeed;
    private float targetRotationSpeed;

    private void Start()
    {
        anim = GetComponent<Animator>(); // Получаем ссылку на компонент аниматора
        capsuleCollider = GetComponent<CapsuleCollider>();
        currentHeight = capsuleCollider.height; // Инициализируем текущую высоту
        currentSpeed = walkSpeed; // Инициализируем начальную скорость как скорость ходьбы
        currentRotationSpeed = walkRotationSpeed; // Инициализируем начальную скорость вращения как скорость ходьбы
    }

    void Update()
    {
        HandleInput();
        UpdateMovementState();
        UpdateRotation();
        UpdateAnimation();
        UpdateColliderHeight();
        HandleJump();
        UpdateTimeInAir();
        g = IsGrounded();
    }

    // Обработка ввода
    private void HandleInput()
    {
        // Получаем направление движения от камеры.
        Vector3 forward = cam.forward;
        Vector3 right = cam.right;

        // Очищаем вертикальную составляющую направления, 
        // чтобы персонаж не двигался вверх или вниз.
        forward.y = 0;
        right.y = 0;

        // Нормализуем векторы направления, чтобы они имели длину 1.
        forward.Normalize();
        right.Normalize();

        // Вычисляем вектор движения на основе ввода пользователя.
        movement = (forward * Input.GetAxis("Vertical") + right * Input.GetAxis("Horizontal")).normalized;

        // Определяем, бежит ли персонаж.
        isRunning = Input.GetKey(KeyCode.LeftShift);

        // Определяем, сидит ли персонаж.
        if (Input.GetKeyDown(KeyCode.C)) { isSiting = !isSiting; } // Переключаем состояние сидения при нажатии на клавишу C
    }

    // Обновление состояния движения
    private void UpdateMovementState()
    {
        // Плавно изменяем скорость и скорость вращения
        targetSpeed = walkSpeed; // Начальная скорость - скорость ходьбы
        targetRotationSpeed = walkRotationSpeed; // Начальная скорость вращения - скорость ходьбы

        // Устанавливаем начальные значения для высоты и смещения
        targetHeight = animationHeights["not Sit"];
        colliderOffset = new Vector3(0f, currentHeight / 2f);

        // Проверяем состояние движения и обновляем параметры
        if (isJumping)
        {
            SetMovementStateJumping();
        }
        else if (isRunning && !isSiting)
        {
            SetMovementStateRunning();
        }
        else if (!isRunning && isSiting)
        {
            SetMovementStateSitting();
        }
        else if (isRunning && isSiting)
        {
            SetMovementStateSittingAndRunning();
        }

        // Используем Lerp для плавного изменения скорости и скорости вращения
        currentSpeed = Mathf.Lerp(currentSpeed, targetSpeed, Time.deltaTime * speedChangeRate); // Плавное изменение текущей скорости к целевой скорости
        currentRotationSpeed = Mathf.Lerp(currentRotationSpeed, targetRotationSpeed, Time.deltaTime * speedChangeRate); // Плавное изменение текущей скорости вращения к целевой скорости вращения
    }

    private void SetMovementStateJumping()
    {
        // Скорость и вращение при прыжке
        targetSpeed = jumpSpeed;
        targetRotationSpeed = jumpRotationSpeed; // Скорость вращения в прыжке (уже есть)
    }

    // Установка параметров для бега
    private void SetMovementStateRunning()
    {
        targetSpeed = runSpeed; // Устанавливаем целевую скорость как скорость бега
        targetRotationSpeed = runRotationSpeed; // Устанавливаем целевую скорость вращения как скорость вращения при беге
    }

    // Установка параметров для сидения
    private void SetMovementStateSitting()
    {
        targetSpeed = sitSpeed; // Устанавливаем целевую скорость как скорость сидения
        targetRotationSpeed = sitRotationSpeed; // Устанавливаем целевую скорость вращения как скорость вращения при сидении
        anim.SetFloat("SitSpeed", 0.5f);

        targetHeight = animationHeights["Sit"];
        colliderOffset = new Vector3(0f, currentHeight / 2f, 0.2f);
    }

    // Установка параметров для сидения с бегом
    private void SetMovementStateSittingAndRunning()
    {
        targetSpeed = sitNrunSpeed; // Устанавливаем целевую скорость как скорость сидения
        targetRotationSpeed = sitNrunRotationSpeed; // Устанавливаем целевую скорость вращения как скорость вращения при сидении
        anim.SetFloat("SitSpeed", 0.75f);

        targetHeight = animationHeights["Sit"];
        colliderOffset = new Vector3(0f, currentHeight / 2f, 0.2f);
    }

    // Обновление поворота
    private void UpdateRotation()
    {
        if (movement != Vector3.zero) // Если персонаж движется
        {
            // Поворачиваем персонажа в направлении движения.
            transform.rotation = Quaternion.Slerp(transform.rotation, Quaternion.LookRotation(movement), Time.deltaTime * currentRotationSpeed); // Вращаем персонажа с текущей скоростью вращения
        }
    }

    // Обновление анимации
    private void UpdateAnimation()
    {
        if (movement != Vector3.zero) // Если персонаж движется
        {
            // Перемещаем персонажа в направлении движения.
            transform.position = Vector3.MoveTowards(transform.position, transform.position + movement, currentSpeed * Time.deltaTime); // Перемещаем персонажа с текущей скоростью

            // Анимируем персонажа.
            anim.SetBool("isWalking", true); // Анимируем ходьбу
            anim.SetBool("isRunning", isRunning); // Анимируем бег
            anim.SetBool("isSiting", isSiting); // Анимируем сидение
        }
        else // Если персонаж не движется
        {
            // Если персонаж не двигается, то устанавливаем анимацию в состояние покоя.
            anim.SetBool("isWalking", false); // Останавливаем анимацию ходьбы
            anim.SetBool("isRunning", false); // Останавливаем анимацию бега
            anim.SetBool("isSiting", isSiting); // Останавливаем анимацию сидения
        }
        anim.SetBool("isJumping", isJumping); // Анимируем прыжок
    }

    // Обновление высоты коллайдера
    private void UpdateColliderHeight()
    {
        // Плавно изменяем высоту коллайдера
        currentHeight = Mathf.SmoothDamp(currentHeight, targetHeight, ref velocity, smoothTime);
        capsuleCollider.height = currentHeight;
        capsuleCollider.center = new Vector3(colliderOffset.x, currentHeight / 2f, colliderOffset.z);
    }

    // Метод для обработки прыжка
    private void HandleJump()
    {
        // Проверка нажатия пробела
        if (Input.GetKeyDown(KeyCode.Space) && IsGrounded())
        {
            // Активируем флажок прыжка в аниматоре
            isJumping = true;

            // Сохраняем текущую скорость
            jumpVelocity = movement * currentSpeed;

            // Добавляем импульс вверх и вперед
            GetComponent<Rigidbody>().AddForce(Vector3.up * jumpForce + jumpVelocity, ForceMode.Impulse);

            // Временно отключаем считывание клавиш движения
            movement = Vector3.zero;
        }

        // Деактивация флага прыжка при касании земли
        if (IsGrounded() && isJumping)
        {
            // Проверяем, достаточно ли времени персонаж провел в воздухе
            if (timeInAir >= timeInAirThreshold)
            {
                isJumping = false;
            }

            // Возобновляем считывание ввода после приземления
            movement = (cam.forward * Input.GetAxis("Vertical") + cam.right * Input.GetAxis("Horizontal")).normalized;
        }
    }

    // Метод для обновления времени в воздухе
    private void UpdateTimeInAir()
    {
        if (!IsGrounded())
        {
            timeInAir += Time.deltaTime;
        }
        else
        {
            timeInAir = 0f; // Сбрасываем время в воздухе при касании земли
        }
    }

    // Метод для проверки, находится ли персонаж на земле
    private bool IsGrounded()
    {
        // Направление луча (прямо вниз)
        Vector3 rayDirection = Vector3.down;

        // Точка начала луча (немного выше центра персонажа)
        Vector3 rayOrigin = transform.position + Vector3.up * 0.1f;

        // Проверяем столкновение с землей
        RaycastHit hit;
        if (Physics.Raycast(rayOrigin, rayDirection, out hit, 0.3f))
        {
            // Debug.Log("Персонаж на земле!");
            return true;
        }
        // Debug.Log("Персонаж в воздухе!");
        return false;
    }
}
