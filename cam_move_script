using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class cam_script : MonoBehaviour
{
    [Header("Основные настройки")]
    public move_script MS;
    public GameObject player;
    public GameObject cam_pos;

    [Space(12)]
    [Header("Вращение камеры")]
    public float sensitivity = 50f;

    [Space(12)]
    [Header("Позиционирование камеры")]
    [Range(0.6f, 2.5f)]
    public float sliderValue;
    public float sittingYOffset = 0.75f;
    public float standingYOffset = 1.5f;
    public float smoothTime = 0.5f; // Скорость плавного перемещения

    [Space(12)]
    [Header("Прозрачность препятствий")]
    GameObject[] transparentObjects = new GameObject[10];
    int transparentObjectsCount = 0;

    // Переменные для вращения
    private Vector2 mouseDelta;

    // Переменные для позиционирования
    private Vector3 offcet1;
    private Vector3 offcet2;
    private Vector3 targetPosition;
    private Vector3 velocity = Vector3.zero;

    // Переменные для обработки прозрачности
    private float targetSliderValue;
    private float smoothTransitionSpeed = 12.0f; // Скорость сглаживания

    void Start()
    {
        offcet1 = cam_pos.transform.position - transform.position;
        offcet2 = transform.position - player.transform.position;
        sliderValue = 2.3f;
    }

    void LateUpdate()
    {
        HandleCameraRotation();
        UpdateCameraPosition();
        CheckForObstacles();
        UpdateSliderValue();
    }

    // Вращение камеры
    private void HandleCameraRotation()
    {
        // Получаем изменения позиции мыши с момента последнего кадра.
        mouseDelta = new Vector2(Input.GetAxis("Mouse X"), Input.GetAxis("Mouse Y"));

        // Вращаем объект вокруг своей вертикальной оси (вправо-влево).
        transform.Rotate(Vector3.up, mouseDelta.x * sensitivity * Time.deltaTime);

        // Вращаем объект вокруг своей горизонтальной оси (вверх-вниз).
        transform.Rotate(Vector3.right, -mouseDelta.y * sensitivity * Time.deltaTime);

        // Ограничиваем вращение по вертикали 
        // (реализовать ограничения более читаемым образом, например, с помощью метода ClampAngle).
        transform.eulerAngles = new Vector3(
            Mathf.Clamp(transform.eulerAngles.x, 0f, 60f),
            transform.eulerAngles.y,
            0);
    }

    //  Рассчитывание позиции камеры 
    private void UpdateCameraPosition()
    {
        // Изменяем offcet с помощью значения ползунка
        Vector3 direction = (cam_pos.transform.position - transform.position).normalized;
        offcet1 = direction * sliderValue;

        // Перемещаем камеру в положение, которое находится на расстоянии offcet от игрока.
        cam_pos.transform.position = transform.position + offcet1;

        // Получаем целевую позицию в зависимости от состояния сидения
        targetPosition = player.transform.position + offcet2;
        targetPosition.y = MS.isSiting ? sittingYOffset : standingYOffset;

        // Плавное перемещение по оси Y
        transform.position = new Vector3(
            targetPosition.x,
            Mathf.SmoothDamp(transform.position.y, targetPosition.y, ref velocity.y, smoothTime),
            targetPosition.z
        );
    }

    // Проверка коллизий лучей 
    private void CheckForObstacles()
    {
        Vector3 TP = transform.position; // позиция cam_point
        Vector3 cam_posTP = cam_pos.transform.position; // позиция cam_pos
        Vector3 direction = (cam_pos.transform.position - transform.position).normalized;

        // Желтый луч: cam_point -> cam_pos (длина = sliderValue)
        Debug.DrawLine(TP, cam_posTP, Color.yellow);
        // Красный луч: cam_pos -> направление от cam_point (длина = initialDistance - sliderValue)
        Debug.DrawLine(cam_posTP, cam_posTP + direction * (2.3f - sliderValue), Color.red);

        RaycastHit hit;

        // Первый луч (желтый): 
        if (CheckRaycastHit(TP, direction, sliderValue, out hit) && hit.collider.gameObject.tag == "obstacle")
        {
            // Плавно уменьшаем targetSliderValue до расстояния до объекта, но не меньше минимального значения
            targetSliderValue = Mathf.Lerp(targetSliderValue, Mathf.Max(0.6f, Vector3.Distance(TP, hit.point)), Time.fixedDeltaTime * smoothTransitionSpeed);

            // Рекурсивно делаем прозрачными все объекты с тегом "obstacle" внутри найденного объекта
            MakeObstacleTransparentRecursive(hit.collider.gameObject);

            // Добавляем объект в массив transparentObjects, если его там еще нет
            if (!ArrayContainsObject(transparentObjects, transparentObjectsCount, hit.collider.gameObject))
            {
                transparentObjects[transparentObjectsCount] = hit.collider.gameObject;
                transparentObjectsCount++;
            }
        }
        else
        {
            // Если желтый луч ни с чем не пересекается, проверяем красный луч
            if (CheckRaycastHit(cam_posTP, -direction, 2.3f - sliderValue, out hit) && hit.collider.gameObject.tag == "obstacle")
            {
                // Плавно уменьшаем targetSliderValue до расстояния до объекта, но не меньше минимального значения
                targetSliderValue = Mathf.Lerp(targetSliderValue, Mathf.Max(0.6f, 2.3f - Vector3.Distance(cam_posTP, hit.point)), Time.deltaTime * smoothTransitionSpeed);

                // Рекурсивно делаем прозрачными все объекты с тегом "obstacle" внутри найденного объекта
                MakeObstacleTransparentRecursive(hit.collider.gameObject);

                // Добавляем объект в массив transparentObjects, если его там еще нет
                if (!ArrayContainsObject(transparentObjects, transparentObjectsCount, hit.collider.gameObject))
                {
                    transparentObjects[transparentObjectsCount] = hit.collider.gameObject;
                    transparentObjectsCount++;
                }
            }
            else
            {
                // Если ни один луч ни с чем не пересекается, плавно увеличиваем targetSliderValue до максимального значения
                targetSliderValue = Mathf.Lerp(targetSliderValue, 2.3f, Time.deltaTime * smoothTransitionSpeed);

                // Возвращаем непрозрачность всем объектам в массиве
                for (int i = 0; i < transparentObjectsCount; i++)
                {
                    if (transparentObjects[i] != null)
                    {
                        MakeObstacleOpaque(transparentObjects[i]);
                    }
                }

                // Очищаем массив
                transparentObjectsCount = 0;
            }
        }
    }

    //  Обновление значения sliderValue 
    private void UpdateSliderValue()
    {
        // Плавно перемещаем sliderValue к целевому значению
        sliderValue = Mathf.Lerp(sliderValue, targetSliderValue, Time.fixedDeltaTime * 5.0f);

        // Применяем полученное значение sliderValue к позиции cam_pos
        cam_pos.transform.position = transform.position + (cam_pos.transform.position - transform.position).normalized * sliderValue;
    }

    // Метод для проверки коллизий лучей (применить к обоим лучам)
    private bool CheckRaycastHit(Vector3 startPos, Vector3 direction, float distance, out RaycastHit hit)
    {
        return Physics.Raycast(startPos, direction, out hit, distance);
    }

    // Функция для проверки, есть ли объект в массиве 
    private bool ArrayContainsObject(GameObject[] array, int count, GameObject target)
    {
        for (int i = 0; i < count; i++)
        {
            if (array[i] == target)
            {
                return true;
            }
        }
        return false;
    }

    // Функция для изменения прозрачности препятствий 
    private void MakeObstacleTransparent(GameObject obstacle)
    {
        // Получаем Renderer препятствия
        Renderer obstacleRenderer = obstacle.GetComponent<Renderer>();
        if (obstacleRenderer != null)
        {
            // Устанавливаем прозрачность
            Color color = obstacleRenderer.material.color;
            color.a = 0.0f; // Значение прозрачности (0 - полностью прозрачный, 1 - полностью непрозрачный)
            obstacleRenderer.material.color = color;
        }
    }

    // Функция для возвращения препятствий в непрозрачное состояние 
    private void MakeObstacleOpaque(GameObject obstacle)
    {
        // Получаем Renderer препятствия
        Renderer obstacleRenderer = obstacle.GetComponent<Renderer>();
        if (obstacleRenderer != null)
        {
            // Устанавливаем непрозрачность
            Color color = obstacleRenderer.material.color;
            color.a = 1.0f; // Значение прозрачности (0 - полностью прозрачный, 1 - полностью непрозрачный)
            obstacleRenderer.material.color = color;
        }
    }

    // Рекурсивная функция для создания прозрачности объектов с тегом "obstacle" 
    void MakeObstacleTransparentRecursive(GameObject obj)
    {
        MakeObstacleTransparent(obj);

        // Добавляем объект в массив transparentObjects, если его там еще нет
        if (!ArrayContainsObject(transparentObjects, transparentObjectsCount, obj))
        {
            transparentObjects[transparentObjectsCount] = obj;
            transparentObjectsCount++;
        }

        // Проверяем всех дочерних объектов
        foreach (Transform child in obj.transform)
        {
            if (child.gameObject.tag == "obstacle")
            {
                MakeObstacleTransparentRecursive(child.gameObject);
            }
        }
    }
}
